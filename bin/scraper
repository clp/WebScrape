#! /usr/bin/env perl

# scraper  clpoda  2012_0323
# PC-batbug:/home/clpoda/p/WebScrape/bin
# Time-stamp: <Sat 2012 Apr 14 07:18:13 PMPM clpoda>
# Scrape the wsj.com site for letters to the editor
#
# Plan
# Build a release from this experimental code.
# Divide this code into a back-end web scraping module,
# and a program w/ site-specific code & data for wsj.com
# Status
# Fri2012_0323_12:51  Scraper works; now parse the data.
# Thu2012_0329_09:24  Parsing topics OK; get author data OK.
# Fri2012_0330_14:41  Extract each letter & save for analysis.
#   Extract is OK; but no metadata fields are stored for simple
#   retrieval & analysis.
# Wed2012_0404_21:07  Save letter text & metadata into a structure.
# Thu2012_0412_22:07  Fix parse bugs-not separating letters into files properly.
# Fri2012_0413_12:09  Handle letter w/ >1 author correctly.
#
# ---------------------------------------------------------------

# For format of the web page: see codenotes.otl file.

use strict;
use warnings;

use Data::Dumper;
use File::Path qw(remove_tree make_path);
use File::Slurp;
use Getopt::Long;
use HTML::Element::Library;
use HTML::TreeBuilder;
use JSON;
use Log::Log4perl qw(:easy);
use WWW::Mechanize;
use DateTime::Format::Natural;
use Try::Tiny;
use feature qw( switch say );

my $USE_LOCAL_DATA = 1;    # 1=Do not query web site.
our $VERSION = '0.10';

# Initialize
my $source_name = "wsj";
my $domain_name = "wsj.com";
my $start_url
    = qq{http://online.wsj.com/public/page/letters.html};    #CFG

my $program = $0;
$program =~ s{\A.*/}{};    # strip leading path, if any
my $authors_count;
my %current_letter = ();
my $daily_dir;
my $data_src = "unknown, maybe __DATA__";
my $dt;
my $letters_count;

my $log_dir = "./log";
my $log_file = $log_dir . "$program.log";

# Set up logging.  Specify level, eg:
# level => $DEBUG,
# level => $INFO,
# level  => $WARN,
Log::Log4perl->easy_init(
  { level => $DEBUG,
    file  => ">>$program.debug.log"
  }
);

unless ( GetOptions( 'start_url=s' => \$start_url, ) ) {
  die usage();
}
unless ($start_url) {
  die
      "$program died: No url found in file or on command line.\n\n",
      usage();
}


#TBD Based on Index.pm modulino code, Sun2012_0318_16:46: keep or toss?
__PACKAGE__->new->run unless caller;

sub run { #------------------------------------------------------
  my ($application) = @_;
  my $start_time = localtime();

  DEBUG("Started run() at $start_time");

  ## Initialize --------------------------------------------------
  $authors_count = 0;
  $letters_count = 0;
  my $rootdir   = ".";                #CFG

  ##OPT-DBG
  init_dirs( $rootdir, "/WebScrape/wsj/tmp" );

  ## Get start page w/ data.  ------------------------------------
  my $mech = WWW::Mechanize->new();
  $mech->agent_alias('Linux Mozilla');
  my $start_page;
  my $tree;
  if ($USE_LOCAL_DATA) {
    ## Read the local file into $start_page for correct handling
    ## of raw data, regardless of which branch is taken.
    $start_page = read_file(
      #TBD "$rootdir/p/WebScrape/data/wsj/wsj.lte.full.2012_0408.raw"
      "$rootdir/data/wsj/wsj.lte.full.2012_0408.raw"
    );

    ## FULL "$rootdir/p/WebScrape/data/wsj/wsj.lte.full.2012_0408.raw"
    ## TST1 "$rootdir/p/WebScrape/data/wsj/wsj.lte.html");
    ## TST2 "$rootdir/p/WebScrape/data/wsj/wsj.lte.2authors.raw");
    ## OK "$rootdir/p/WebScrape/data/wsj/wsj.lte.1Letter.1author.data.raw");
    ## OK "$rootdir/p/WebScrape/data/wsj/wsj.lte.2letters.raw");
    ## TST "$rootdir/p/WebScrape/data/wsj/wsj.lte.2letters.italics.inside.raw");
    $data_src = "local copy of web page";
  }
  else {
    $start_page = get_start_page( $mech, $start_url );
    $data_src = "web";
  }
  $tree     = HTML::TreeBuilder->new_from_content($start_page);

  ##TBD Verify page title: </script><title>Letters - WSJ.com</title>

  init_dirs( $rootdir, "/wsj/lte");
  my $raw_dir = "$rootdir/wsj/lte";
  save_raw_data( $source_name, $raw_dir, $start_page, $tree );


  ## TBF b.9. serverTime may be different from the date when
  ## the letters are printed in the wsj newspaper.
  ## Format of serverTime = new Date("April 06, 2012 00:45:28");
  my ($pub_date_raw)
      = $tree->as_HTML =~ qr{serverTime = new Date\("(.*?)"\)};
  say "DBG date from web server: ,$pub_date_raw,";
  my $date_parser = DateTime::Format::Natural->new();
  $dt = $date_parser->parse_datetime($pub_date_raw);

  ## TBD Move to where $dt is used?
  if ( $date_parser->success ) {
    $daily_dir = initialize_output_dir();
  }
  else {
    DEBUG $date_parser->error;
  }

  ## Get topic data.
  my @all_letters_to_editor;
  my @topics = extract_topics($tree);

  my $topic_parent = $tree->look_down(
    _tag  => 'div',
    class => "",
  );

  my @lines_under_a_topic;
  my $topic_number = 0;
  my $topic_start;

  ## Loop on each topic. -----------------------------------------
TOPIC:
  foreach (@topics) {
    my $current_topic = $_->{_content}[0];
    $current_topic =~ s/\s+$//;
    say "DBG topic: ", $current_topic;

    $topic_start = $topic_parent->look_down(
      _tag => 'h1',
      sub { $_[0]->as_text =~ qr{$current_topic}i }
    );

    if ($topic_start) {
      @lines_under_a_topic = $topic_start->siblings;
      $topic_number++;
    }
    else {
      DEBUG
          "\$topic_start not found for number: ,$topic_number,";
      $topic_number++;
      next TOPIC;
    }

    my $current_author      = '';
    my $current_letter_text = '';
    my $details;
    my $prior_author = '';
    my $letter_line;

    ## Add newline for better readability on screen.
    push @all_letters_to_editor, { letter_content => "\n" };

    ## First loop for letters.
LINE:
    while (@lines_under_a_topic) {
      ## Remove lines from the array.
      $letter_line = shift @lines_under_a_topic;

      ## DBG say "DBG LINE block: \$letter_line->as_HTML: ,", $letter_line->as_HTML;
      if ($letter_line) {

        ## DBG Save each line for debug.
        push @all_letters_to_editor,
            { letter_content => $letter_line->as_text };

        ## Save items for analysis.
        $current_letter_text .= $letter_line->as_text;
      }
      else {
        next LINE;
      }

      ## Author loop: the second loop for letters.
      ## Extract all author data, then return to LINE loop.
      if ( $letter_line->as_HTML =~ /<b>/ ) {

        ## Now handle all following lines
        ## as author data, until end of current letter.
        $authors_count++;
        $current_author = $letter_line->as_text;
        say
            "DBG if <b> block  \$current_author: ,$current_author,";
        $current_letter{author}{$current_author}{name}
            = $current_author;

        ## Assume the <b> tag marks end of letter body.
        $current_letter{body}  = $current_letter_text;
        $current_letter{topic} = $current_topic;

        ## Clear the var to prepare for next letter.
        $current_letter_text = '';

        ## Loop to get current author data.
        my $current_line;
        while (@lines_under_a_topic) {
          $current_line = shift @lines_under_a_topic;

          push @all_letters_to_editor,
              { letter_content => $current_line->as_text };

          if ( $current_line->as_HTML =~ /<a/ ) {
            ## Not reliable marker for end of letter.  See b.21.

            ## Add newline for better readability on screen.
            push @all_letters_to_editor,
                { letter_content => "\n" };

            $letters_count++;
            save_letter_to_file( \%current_letter );
            next LINE;
          }

          elsif ( $current_line->as_HTML =~ /<i>/ ) {
            push @{ $current_letter{author}{$current_author}
                  {details} },
                $current_line->as_text;
          }
          elsif ( $current_line->as_HTML =~ /<b>/ ) {
            if ( $current_line->as_text eq $current_author ) {
              ## Skip $current_author - already handled.
              next;
            }

            ## Handle the new author for an existing letter.
            $current_author = $current_line->as_text;
            push @{ $current_letter{author}{$current_author}
                  {name} },
                $current_author;

            $authors_count++;
            next;    # Get data for this new author.
          }
          else {
            ## Assume end of the letter found.
            last;
          }

        }    # End of while for author loop.

        ## If no more lines are under the topic, save the letter
        ## to a file.  This saves letters under topics w/ only
        ## one letter, that do not have an <a> tag that marks
        ## the end of a letter.
        $letters_count++;
        save_letter_to_file( \%current_letter );

        ## Add newline for better readability on screen.
        push @all_letters_to_editor, { letter_content => "\n" };

      }    # End of <b> loop.
    }    # End LINE loop.
  }    # End TOPIC loop.

  $tree->delete;

  ##---------------------------------------------------------------
  ## Save data from all letters found.
  write_file( "all_letters", "" );
  foreach (@all_letters_to_editor) {
    append_file( "all_letters", { binmode => ':utf8' },
      values %$_ )
        or DEBUG( 'save_letters_data', $!, $source_name );
    append_file( "all_letters", { binmode => ':utf8' }, "\n" );
  }

  ## Print all letters to screen.
  use Text::Wrap;
  say "\nLetters to the Editor from $source_name",
      " for web site content dated $pub_date_raw\n";
  foreach (@all_letters_to_editor) {
    say { $application->{output_fh} }
        wrap( "\t", '  ', values %{$_} );
  }

  ##---------------------------------------------------------------
  ## Print summary stats at end of the program.

  my $done_time = localtime();
  my ($end_msg1);
  $end_msg1
      = "\nSummary of $0:\n"
      . "  Using data src ,$data_src, for letters to the editor"
      . " in $source_name.\n"
      . "  Found $authors_count authors for"
      . " $letters_count letters to the editor\n"
      . "  in $source_name, for web site content dated $pub_date_raw.\n";

  DEBUG($end_msg1);
  print { $application->{output_fh} } $end_msg1 . "\n";

}    # End of run().

exit 1;

#
#
# Subroutines ---------------------------------------------------
#
#
sub new { #------------------------------------------------------
  my ($class) = @_;
  my $application = bless {}, $class;
  $application->init;
  $application;
}

sub init { #-----------------------------------------------------
  ## TBD Add some or all init code here later.
  my ($application) = @_;
  $application->{output_fh} = \*STDOUT;
}

sub output_fh { #------------------------------------------------
  my ( $application, $fh ) = @_;
  if ($fh) {
    $application->{output_fh} = $fh;
  }
  $application->{output_fh};
}

sub usage { #----------------------------------------------------
  return <<"eousage";
Usage:
  $program -u url

$program requests a web site to return a page, then extracts
letters to the editor, and saves and displays them.

See combined results at ./all_letters.

See JSON output files at ./wsj/yyyy/mmdd/NN.


Options to control the query

-url string              The full http address to retrieve.
                         Required.
eousage
}

sub init_dirs { #------------------------------------------------
  my ( $parent, $child ) = @_;
  if ( -d "$parent/$child" ) {
    remove_tree("$parent/$child");
  }
  make_path("$parent/$child");
}

sub get_start_page { #-------------------------------------------
  my ( $mech, $start_url ) = @_;
  my $response;
  try {
    $response = $mech->get($start_url);
  }
  catch {
    my $msg = "ERR: DIE: Caught error while getting web page: $_"
        . "  response->status_line: [$response->status_line].";
    ##ORG DEBUG( 'NoShow', $msg, $source_name );
    DEBUG( $msg, $source_name );
    die "ERR: Cannot get web page [$start_url]; try later.";
  };

  if ( !$response->is_success ) {
    my $msg = "Bad response to request for [$start_url]: "
        . $response->status_line;
    ##ORG DEBUG( 'NoShow', $msg, $source_name );
    DEBUG( $msg, $source_name );
    die
        "ERR: Got bad response to request for [$start_url]; try later.";
  }
  return $mech->content();
}

## Write each letter to a separate file.
sub save_letter_to_file { #--------------------------------------
  my $ref_current_letter = shift;
  my $count              = $letters_count;

  ## Add leading zeroes to get 2-character strings.
  for ($count) {
    $_ = "0" . $_ if $_ <= 9;
  }

  write_file(
    "./$daily_dir/$count",
    { binmode => ':utf8' },
    encode_json($ref_current_letter)
  ) or DEBUG( 'save_one_letter_data', $!, $source_name );

  %current_letter = ();
}

sub save_raw_data { #--------------------------------------------
  my ( $source_name, $raw_dir, $start_page, $tree ) = @_;

  ## Save structured view of web page.
  my $treeout;
  open( $treeout, '>', "$raw_dir/wsj.lte.treedump" );
  binmode $treeout, ':utf8';
  $tree->dump($treeout);
  close($treeout);

  ## Save raw downloaded page & decoded content for debugging.
  my $page_file = "$source_name.lte.raw";
  write_file( "$raw_dir/$page_file", { binmode => ':utf8' },
    $start_page )
      or DEBUG( 'save_raw_data()', $!, $source_name );
  write_file( "tree_builder_dump_as_html", $tree->as_HTML )
      or DEBUG( 'save_raw_data()', $!, $source_name );
  write_file( "tree_builder_dump_as_text",
    { binmode => ':utf8' },
    $tree->as_text )
      or DEBUG( 'save_raw_data()', $!, $source_name );
}

sub extract_topics { #-------------------------------------------
  my $tree   = shift;
  my @topics = $tree->look_down(
    '_tag'  => 'h1',
    'class' => 'boldEighteenTimes',
  );
  return @topics;
}

sub initialize_output_dir {
  my $m = $dt->month;
  my $d = $dt->day;

  ## Add leading zeroes to values used in path, including file
  ## name, to get 2-digit strings.
  for ( $m, $d ) {
    $_ = "0" . $_ if $_ <= 9;
  }

  ## TBD Combine init_dirs & init*dir subs.
  my $daily_dir = "./wsj/" . $dt->year . "/" . $m . $d;
  if ( -d $daily_dir ) {
    remove_tree($daily_dir);
  }
  make_path($daily_dir);
  return $daily_dir;
}

