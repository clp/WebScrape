#! /usr/bin/env perl

# scraper  clpoda  2012_0323
# PC-batbug:/home/clpoda/p/WebScrape/bin
# Time-stamp: <Thu 2012 Mar 29 09:57:11 PMPM clpoda>
# Scrape the wsj.com site for letters to the editor
#
# Plan
# Build a release from this experimental code.
# Divide this code into a back-end web scraping module,
# and a program w/ site-specific code & data for wsj.com
# Status
# Fri2012_0323_12:51  Scraper works; now parse the data.
# Thu2012_0329_09:24  Parsing topics OK; get author data OK.
# Next:  Extract each letter & save for analysis.

#TBD Thu2012_0329_21:54  current issues
#   Fill file all_letters properly: @all_letters_data not right.
#   $topic_start fails for some topics.
#   Get text not hashes for @letter_paragraphs?
#   Find approach that works for all data & use it.
#
# ---------------------------------------------------------------

# Format of the web page: see codenotes.otl file.

use strict;
use warnings;

#TBD use Carp;
use Data::Dumper;
use File::Path qw(remove_tree make_path);
use File::Slurp;
use Getopt::Long;
use HTML::Element::Library;

#TBD use HTML::Entities;
use HTML::TreeBuilder;

# TBD use JSON;
use Log::Log4perl qw(:easy);
use WWW::Mechanize;

#TBD use DateTime;
use Try::Tiny;
use feature qw( switch say );

#TBD use autodie ;
#TBD use Storable;
#TBD use IO::Zlib;

my $USE_LOCAL_DATA = 1;    # 1=Do not query web site.
our $VERSION = '0.01';

# Initialize
my $source_name = "wsj";
my $domain_name = "wsj.com";
my $rootdir     = "/home/clpoda";

#ORG my $outputdir   = "p/WebScrape/scraped_data/wsj/lte"; #CFG
my $outputdir = "p/WebScrape/data/wsj/lte";    #CFG
my $msg;

# Initialize
my $program = $0;
$program =~ s{\A.*/}{};    # strip leading path, if any
my $now = localtime;

#
# Raw data dir, eg, ./, /tmp, /var/tmp, ~/tmp/raw
#ORG my $log_dir = "./";
my $log_dir  = "/home/clpoda/p/WebScrape/log/";
my $log_file = $log_dir . "$program.log";

#TBD # Name the $out_file later; it contains a time stamp.
#TBD my $out_file;
#
#TBD my $data_src = "__DATA__";
#TBD my $data_src = "web";
my $data_src = "local file copy of web page";

# Set up logging.
Log::Log4perl->easy_init(
  {
    #OK level => $INFO,
    #OK level  => $WARN,
    level => $DEBUG,
    file  => ">>$program.log"
  }
);

#
# Prepare to write o/p file.
my $h_log;
open $h_log, ">>$log_file";

my $start_url;
$start_url
    = qq{http://online.wsj.com/public/page/letters.html};    #CFG
unless ( GetOptions( 'start_url=s' => \$start_url, ) ) {
  die usage();
}
unless ($start_url) {
  die
      "$program died: No url found in file or on command line.\n\n",
      usage();
}

my $mech = WWW::Mechanize->new();
$mech->agent_alias('Linux Mozilla');

#TBD Based on Index.pm modulino code, Sun2012_0318_16:46: keep or toss?
__PACKAGE__->new->run unless caller;

sub run { #------------------------------------------------------
  my ($application) = @_;
  my $start_time = localtime();
  #DBG print "\n$0: Started run() at $start_time.\n";
  DEBUG("Started run() at $start_time");

  ##
  ## Initialize --------------------------------------------------
  my $total_letters_count = 0;

  init_dirs( $rootdir, $outputdir );

  ##TMP1 print "   $0: See results at $rootdir/$outputdir when done.\n";
  ##TMP1 print "   $0: See log data at /home/clpoda/p/WebScrape/log/. \n\n";

  ##OPT-DBG
  my $raw_dir = "$rootdir/p/WebScrape/data/wsj/tmp";
  if ( -d $raw_dir ) {
    remove_tree($raw_dir);
  }
  make_path($raw_dir);

  ##
  ## Get start page w/ data.  ------------------------------------
  ##
  my $start_page;
  my $tree;
  if ($USE_LOCAL_DATA) {
    ## Read file into $start_page for correct handling of raw 
    ## data, regardless of which branch is taken.
    $start_page = read_file(
      "$rootdir/p/WebScrape/data/wsj/wsj.lte.html");
    $tree = HTML::TreeBuilder->new_from_content($start_page);
  }
  else {
    $start_page = get_start_page( $mech, $start_url );
    $tree = HTML::TreeBuilder->new_from_content($start_page);
  }

  ##TBD Verify page title: </script><title>Letters - WSJ.com</title>

  ##DBG:
  save_raw_data( $source_name, $raw_dir, $start_page, $tree );

  ##DBG:
  ## write_file( "$rootdir/p/WebScrape/data/wsj/tmp/wsj.lte.html",
    ## $start_page );

  ##DBG say "\n-----------------------------------------------------------";
  ##DBG say "DBG \$tree->as_HTML:\n", $tree->as_HTML;
  ##DBG say "\n-----------------------------------------------------------";
  ##DBG say "DBG \$tree->as_text:\n", $tree->as_text;

  ##
  ## Parse the web page for data.  -------------------------------
  ##
  ## Parse the response & extract desired data. ------------------
  ##   Select the portion of the page that holds our data.
  ##   Grab all text from h1 tag until the next h1 tag, or end-of-letters-marker.
  ##   Extract each letter from the group of letters.
  ##   Parse the text for data: heading, article, letter body, etc.
  my @all_letters_data;
  my @topics = extract_topics($tree);

  ##TBD Wed2012_0328_10:59  i.2. Use siblings() to get all letters.
  my $letter_start = $tree->look_down(
    _tag  => 'div',
    class => "",
    ##TBD )->look_down(
    ##TBD _tag => 'h1'
  );
  #TBR? my @sibs = $letter_start->siblings;
  my @sibs;

  my $letter_text;
  my $letters_under_topic;  #TBR?
  my $letters_under_topic3;  #TBR?
  my $author_name;
  my $author_locn;
  my $author_data = '';
  my $next_sibling_right;
  #ORG my $topic_start = $letter_start;
  my $topic_start;

  ## Loop on each topic. -----------------------------------------
  TOPIC:
  foreach ( 0 .. $#topics ) {    # 0-7 for 8 topics.
    say "DBG topic: ", $topics[$_]->{_content}[0];

    #TBD Make the sub a pattern match? Using the exact heading may be a problem.
    $topic_start = $letter_start->look_down (
      _tag=>'h1',
      sub { $_[0]->as_HTML =~ /$topics[$_]->{_content}[0]/ }
    );
    #TBD Why do some topics fail here-not found?
    if ($topic_start) {
      @sibs = $topic_start->siblings;  # All siblings under $topic_start
    }
    else {
      say "DBG No \$topic_start found here: ,$topic_start,";
      next TOPIC;
    }

    ##DBG $letters_under_topic = $sibs[0]->{_content}[3 * $_]->as_text;
    #TBD9 $letters_under_topic = $sibs[0]->{_content}[ 3 * $_ ]->as_HTML;
    $letters_under_topic3 = $sibs[0]->{_content}[ 3 * $_ ];

    #F my @letter_paragraphs = $letter_start->look_down(
    #TBD7 my @letter_paragraphs = $letters_under_topic2->look_down(
    #TBD7 _tag=>qr/[p|b|i|a|]/,
    #TBD7 );
    my @letter_paragraphs;
    #TBD10 if ( $letters_under_topic3 ) {
    #TBD10 #ORG my @letter_paragraphs = split /<p/, $letters_under_topic2->as_HTML;
    #TBD10 my @letter_paragraphs = split /<p/, $letters_under_topic3;
    #TBD10 say "DBG \@letter_paragraphs:\n###@letter_paragraphs\n###";
    #TBD10 }

    foreach (@sibs) {
      push @letter_paragraphs , $_;
    }
    say "DBG \@letter_paragraphs:\n###@letter_paragraphs\n###";

    my $one_letter_text = '';
    LETTER:
    foreach ( @letter_paragraphs ) {
      #TBD8 if ( $_->{_content}[0] ) {
        #TBD8 $one_letter_text .= $_->{_content}[0];
      if ( $_) {
        $one_letter_text .= $_;
      }
      else {
        next LETTER;
      }
      if ( $_ =~ /<b>/ ) {
        #TBD
        say "DBG Found author, so finished one letter: ";
        say $one_letter_text;
        say "DBG Next: Get & save author data w/ letter.";
        say '###\n';
        push @all_letters_data , $one_letter_text;
        $one_letter_text = '';
        $total_letters_count++;
        next LETTER;
      }
      #TBD5 push @all_letters_data , extract_one_letter_to_editor($_);
    }

    ##TBD $one_paragraph = $sibs[0]->{_content}[0]{_content}[$i];
    ##TBD push @all_letters_data , extract_one_letter_to_editor($_);
    #TBD11 $author_locn = $sibs[0]->{_content}[ 3 * $_ ]
    #TBD11 ->look_down( _tag => 'b' );
    $author_locn = $sibs[0]->parent
        ->look_down( _tag => 'b' );
    last if ( not defined $author_locn );
    ##OK $author_name = $sibs[0]->{_content}[3 * $_]->look_down(_tag=>'b')->as_HTML;
    $author_name = $author_locn->as_HTML;
    ## Get all italic lines until no more are found, when next letter or topic starts,
    ## or at end of all letters:
    ##OK $author_data = $author_locn->look_up(_tag=>'p')->right->look_down(_tag=>'i')->as_HTML;
    ##TBD $next_sibling_right = $author_locn->look_up(_tag=>'p')->right->look_down(_tag=>'i')->as_HTML;
    $next_sibling_right
        = $author_locn->look_up( _tag => 'p' )->right;
    while ( defined $next_sibling_right ) {
      my $nsr_italic
          = $next_sibling_right->look_down( _tag => 'i' );
      last if ( not defined $nsr_italic );
      $author_data .= $nsr_italic->as_HTML;
      $next_sibling_right = $next_sibling_right->right;
    }
    say "DBG author_name: ,$author_name,";
    say "DBG author_data: ,$author_data,";
    #TBD6 push @all_letters_data, $letters_under_topic;
    push @all_letters_data, "\n\n";         #DBG
    $topic_start = $author_locn->look_up(_tag=>'div', class=>"")->right ;
    $author_data = '';
    $total_letters_count++;


    ## Finished w/ one topic; go to the next. -------------------
    ## TBD.
    ##
  }

=begin topics_loop

#TBDtest Wed2012_0328_11:33 

  foreach ( @topics ) {
    my @letters = extract_letters($_);
    foreach ( @letters ) {
      push @all_letters_data , extract_one_letter_to_editor($_);
      $total_letters_count++;
    }
  }

=end topics_loop

=cut

  ##---------------------------------------------------------------
  ## Save data from all letters found.
  write_file( "all_letters", "" );
  foreach (@all_letters_data) {

    #TBD write_file( "all_letters", { binmode => ':utf8' }, $_ )
    append_file( "all_letters", { binmode => ':utf8' }, $_ )
        or DEBUG( 'save_letters_data', $!, $source_name );
  }

  ##---------------------------------------------------------------
  ## Print summary stats at end of the program.
  $tree->delete;

  my $done_time = localtime();
  my ($end_msg1);
  $end_msg1
      = "$0\n"
      . "  using data src ,$data_src,\n"
      . "  ran from $start_time to $done_time.\n"
      . "  Found ,$total_letters_count, letters to the editor in $source_name.\n";

  DEBUG($end_msg1);
  print { $application->{output_fh} } $end_msg1 . "\n";

}    # End of run().

close $h_log;

exit 1;

#
#
# Subroutines ---------------------------------------------------
#
#

sub new { #------------------------------------------------------
  my ($class) = @_;
  my $application = bless {}, $class;
  $application->init;
  $application;
}

sub init { #-----------------------------------------------------
           # TBD Add some or all init code here later.
  my ($application) = @_;
  $application->{output_fh} = \*STDOUT;
}

sub output_fh { #------------------------------------------------
  my ( $application, $fh ) = @_;
  if ($fh) {
    $application->{output_fh} = $fh;
  }
  $application->{output_fh};
}

sub usage { #----------------------------------------------------
  return <<"eousage";
Usage:
  $program -u url

$program requests a web site to return a page, and displays the HTML
data found there.

Options to control the query

-url string              The full http address to retrieve.
                         Required.
eousage
}

sub init_dirs { #------------------------------------------------
  my ( $rootdir, $outputdir ) = @_;
  if ( -d "$rootdir/$outputdir" ) {
    remove_tree("$rootdir/$outputdir");
  }
  make_path("$rootdir/$outputdir");
}

sub get_start_page { #-------------------------------------------
  my ( $mech, $start_url ) = @_;
  my $response;
  try {
    $response = $mech->get($start_url);
  }
  catch {
    my $msg = "ERR: DIE: Caught error while getting web page: $_"
        . "  response->status_line: [$response->status_line].";
    DEBUG( 'NoShow', $msg, $source_name );
    die "ERR: Cannot get web page [$start_url]; try later.";
  };

  if ( !$response->is_success ) {
    my $msg = "Bad response to request for [$start_url]: "
        . $response->status_line;
    DEBUG( 'NoShow', $msg, $source_name );
    die
        "ERR: Got bad response to request for [$start_url]; try later.";
  }
  return $mech->content();
}    # End get_start_page.

sub save_raw_data { #--------------------------------------------
  my ( $source_name, $raw_dir, $start_page, $tree ) = @_;

  ###OPT-DBG
  ## Optional: save raw downloaded page & other content for debugging.

  # Save structured view of web page.
  my $treeout;
  open( $treeout, '>',
    "$rootdir/p/WebScrape/data/wsj/tmp/wsj.lte.treedump" );
  $tree->dump($treeout);
  close($treeout);

  my $page_file = "$source_name.lte.raw";
  write_file( "$raw_dir/$page_file", { binmode => ':utf8' },
    $start_page )
      or DEBUG( 'save_raw_data()', $!, $source_name );
  write_file( "tree_builder_dump_as_html", $tree->as_HTML )
      or DEBUG( 'save_raw_data()', $!, $source_name );
  write_file( "tree_builder_dump_as_text",
    { binmode => ':utf8' },
    $tree->as_text )
      or DEBUG( 'save_raw_data()', $!, $source_name );
  ### End of OPT-DBG
}    # End of sub save_raw_data

#TBD Add subs?
# get_page_with_lte()

sub extract_topics { #-------------------------------------------
  my $tree             = shift;
  my @letter_headlines = $tree->look_down(
    '_tag'  => 'h1',
    'class' => 'boldEighteenTimes',
  );
  $Data::Dumper::Maxdepth = 2;    # 2 shows content
  #DBG say "\nDBG \@letter_headlines:";

  #DBG say Dumper @letter_headlines;
  return @letter_headlines;
}

sub extract_letters { #------------------------------------------
  say "DBG extract_letters()";
  my $topic        = shift;
  my $letter_group = $topic->parent->look_down( '_tag' => 'p', );
  my @letters      = $letter_group->siblings;
  $Data::Dumper::Maxdepth = 2;    # 2 shows content
  say "\nDBG \@letters:";

  #DBG say Dumper @letters;
  return @letters;
}

sub extract_one_letter_to_editor { #-----------------------------
  my $letter = shift;

  #TBD3  my @letter_contents = $letter->parent->look_down(
  my @letter_contents
      = $letter->look_down( '_tag' => 'p', );

  # Collect a list of paragraphs of each letter.
  # my @letter_paragraphs =
  # $letter_headline->parent->look_down( "_tag" => "p", );

  foreach (@letter_contents) {

    #F say "DBG One Para:\n", dump $_;
    #DBG say "DBG One Para:\n";
    $Data::Dumper::Maxdepth = 2;    # 2 shows content of letters.
                                    #DBG say Dumper ($_);
  }

  ## HTML on the page to match:
  ## TBD
#TBD if ($letter_headline) {
#TBD ( $ep_element_6, $hex_id, $show_id ) = $letter_headline->parent->as_HTML =~
#TBD m{.* 'Full.Episodes','(.*?)', \s* (.*?), \s* (\d+?),  .*}ix;
#TBD }
#TBD else {
#TBD return ( 0, 0, 0 );
#TBD }

  return @letter_contents;
}

